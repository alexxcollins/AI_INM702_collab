#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Nov 11 12:01:05 2021

@author: alexxcollins
"""

#%% to test if I can create ABC which defintes how to generate y with x
from numpy.random import default_rng
from abc import ABC, abstractmethod
import numpy as np

class GenerateData(ABC):
    '''
    The base class will generate random Y given parameters for sample size
    beta (coefficients for intercept plus independent variables), variance of
    epsilon and optional X. 
    The X generated by this base class will match dimension of beta and will
    be generated from uniform distribution along each dimension. Subclasses can
    be used to generate or supply difference Xs, with outliers, co-depence etc.
    '''

    def __init__(self, N=1000, beta=(1,2,3), noise_var=1):
        # not sure where to set random seed. Should we do this in Jupyter notebook?
        # and pass into the class?
        self.rng = default_rng(42)
        self.N = N
        self._p = len(beta)-1
        self._p1 = len(beta)
        self.beta = np.array(beta).reshape((self._p1,1))
        # we often use p and p' in regression formulas, so I'm defining both
        # at the moment discourage changing with underscore rather than setters
        self.e_var = 1
        self.e = self._generate_epsilon()
        
    def _generate_epsilon(self):
        return self.rng.normal(0, self.e_var**(1/2), 
                               size=(self.N,1))
    
    @abstractmethod
    def generate_X(self, low=None, high=None):
        pass
    
    def generate_y(self):
        return np.matmul(self.X, self.beta) + self.e
    
    def generate_dataset(self):
        self.y = self.generate_y(self)
        
    # @property
    # def y(self):
    #     return self.generate_y()
    
            
class UniformX(GenerateData):
    
    def generate_X(self, low=-10, high=10):
        X = self.rng.uniform(low=low, high=high, size=(self.N,self._p))
        X0 = np.ones((self.N,1))
        self.X =  np.concatenate([X0, X], axis=1)

    def generate_y(self):
        return np.matmul(self.X, self.beta) + self.e
    
    def generate_dataset(self):
        self.y = self.generate_y()
